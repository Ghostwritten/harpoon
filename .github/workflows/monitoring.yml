name: Release Monitoring

on:
  release:
    types: [published]
  schedule:
    # ÊØèÂ∞èÊó∂Ê£ÄÊü•‰∏ÄÊ¨°ÂèëÂ∏ÉÂêéÁöÑÊåáÊ†á
    - cron: '0 * * * *'
  workflow_dispatch:
    inputs:
      release_tag:
        description: 'Release tag to monitor (e.g., v1.1.0)'
        required: true
        type: string
      check_type:
        description: 'Type of monitoring check'
        required: true
        default: 'all'
        type: choice
        options:
        - all
        - downloads
        - performance
        - errors
        - feedback

permissions:
  contents: read
  issues: write
  discussions: write

env:
  MONITORING_RETENTION_DAYS: 30

jobs:
  # Ê£ÄÊµãÂèëÂ∏É‰ø°ÊÅØ
  detect-release:
    name: Detect Release
    runs-on: ubuntu-latest
    outputs:
      release-tag: ${{ steps.release.outputs.tag }}
      release-date: ${{ steps.release.outputs.date }}
      should-monitor: ${{ steps.release.outputs.should-monitor }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Determine release to monitor
      id: release
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          RELEASE_TAG="${{ github.event.inputs.release_tag }}"
        elif [ "${{ github.event_name }}" = "release" ]; then
          RELEASE_TAG="${{ github.event.release.tag_name }}"
        else
          # Ëé∑ÂèñÊúÄÊñ∞ÂèëÂ∏É
          RELEASE_TAG=$(gh release list --limit 1 --json tagName --jq '.[0].tagName' 2>/dev/null || echo "")
        fi
        
        if [ -z "$RELEASE_TAG" ]; then
          echo "should-monitor=false" >> $GITHUB_OUTPUT
          echo "No release found to monitor"
          exit 0
        fi
        
        echo "tag=$RELEASE_TAG" >> $GITHUB_OUTPUT
        echo "should-monitor=true" >> $GITHUB_OUTPUT
        
        # Ëé∑ÂèñÂèëÂ∏ÉÊó•Êúü
        RELEASE_DATE=$(gh release view "$RELEASE_TAG" --json publishedAt --jq '.publishedAt' 2>/dev/null || date -u +"%Y-%m-%dT%H:%M:%SZ")
        echo "date=$RELEASE_DATE" >> $GITHUB_OUTPUT
        
        echo "Monitoring release: $RELEASE_TAG (published: $RELEASE_DATE)"
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ÁõëÊéß‰∏ãËΩΩÈáèÂíå‰ΩøÁî®ÊÉÖÂÜµ
  monitor-downloads:
    name: Monitor Downloads
    runs-on: ubuntu-latest
    needs: detect-release
    if: needs.detect-release.outputs.should-monitor == 'true'
    outputs:
      download-stats: ${{ steps.stats.outputs.stats }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Get download statistics
      id: stats
      run: |
        RELEASE_TAG="${{ needs.detect-release.outputs.release-tag }}"
        
        echo "üìä Collecting download statistics for $RELEASE_TAG..."
        
        # Ëé∑ÂèñÂèëÂ∏É‰ø°ÊÅØÂíå‰∏ãËΩΩÁªüËÆ°
        RELEASE_INFO=$(gh release view "$RELEASE_TAG" --json assets,downloadCount,publishedAt)
        
        TOTAL_DOWNLOADS=$(echo "$RELEASE_INFO" | jq '.downloadCount // 0')
        PUBLISHED_AT=$(echo "$RELEASE_INFO" | jq -r '.publishedAt')
        
        echo "Total downloads: $TOTAL_DOWNLOADS"
        echo "Published at: $PUBLISHED_AT"
        
        # ËÆ°ÁÆóÂèëÂ∏ÉÂêéÁöÑÊó∂Èó¥
        PUBLISHED_TIMESTAMP=$(date -d "$PUBLISHED_AT" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$PUBLISHED_AT" +%s)
        CURRENT_TIMESTAMP=$(date +%s)
        HOURS_SINCE_RELEASE=$(( (CURRENT_TIMESTAMP - PUBLISHED_TIMESTAMP) / 3600 ))
        
        echo "Hours since release: $HOURS_SINCE_RELEASE"
        
        # ËÆ°ÁÆó‰∏ãËΩΩÈÄüÁéá
        if [ $HOURS_SINCE_RELEASE -gt 0 ]; then
          DOWNLOADS_PER_HOUR=$(( TOTAL_DOWNLOADS / HOURS_SINCE_RELEASE ))
        else
          DOWNLOADS_PER_HOUR=$TOTAL_DOWNLOADS
        fi
        
        echo "Downloads per hour: $DOWNLOADS_PER_HOUR"
        
        # Ëé∑ÂèñÂêÑÂπ≥Âè∞‰∏ãËΩΩÁªüËÆ°
        echo "$RELEASE_INFO" | jq -r '.assets[] | "\(.name): \(.downloadCount // 0) downloads"'
        
        # ËæìÂá∫ÁªüËÆ°‰ø°ÊÅØ
        STATS_JSON=$(cat << EOF
        {
          "total_downloads": $TOTAL_DOWNLOADS,
          "hours_since_release": $HOURS_SINCE_RELEASE,
          "downloads_per_hour": $DOWNLOADS_PER_HOUR,
          "published_at": "$PUBLISHED_AT"
        }
        EOF
        )
        
        echo "stats=$STATS_JSON" >> $GITHUB_OUTPUT
        
        # ËØÑ‰º∞‰∏ãËΩΩË°®Áé∞
        if [ $HOURS_SINCE_RELEASE -ge 24 ]; then
          if [ $DOWNLOADS_PER_HOUR -ge 10 ]; then
            echo "üéâ Excellent download performance!"
          elif [ $DOWNLOADS_PER_HOUR -ge 5 ]; then
            echo "‚úÖ Good download performance"
          elif [ $DOWNLOADS_PER_HOUR -ge 1 ]; then
            echo "‚ö†Ô∏è  Moderate download performance"
          else
            echo "üìâ Low download performance - may need promotion"
          fi
        fi
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Store download metrics
      run: |
        RELEASE_TAG="${{ needs.detect-release.outputs.release-tag }}"
        TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        
        # ÂàõÂª∫ÊåáÊ†áÊñá‰ª∂
        mkdir -p .monitoring/downloads
        
        cat > ".monitoring/downloads/${RELEASE_TAG}-${TIMESTAMP}.json" << EOF
        {
          "timestamp": "$TIMESTAMP",
          "release_tag": "$RELEASE_TAG",
          "metrics": ${{ steps.stats.outputs.stats }}
        }
        EOF
        
        echo "üìÅ Download metrics stored"

    - name: Upload monitoring data
      uses: actions/upload-artifact@v3
      with:
        name: download-metrics
        path: .monitoring/downloads/
        retention-days: ${{ env.MONITORING_RETENTION_DAYS }}

  # ÁõëÊéßÊÄßËÉΩÊåáÊ†á
  monitor-performance:
    name: Monitor Performance
    runs-on: ubuntu-latest
    needs: detect-release
    if: needs.detect-release.outputs.should-monitor == 'true'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download and test release binary
      run: |
        RELEASE_TAG="${{ needs.detect-release.outputs.release-tag }}"
        
        echo "üîç Testing performance of $RELEASE_TAG..."
        
        # ‰∏ãËΩΩLinux AMD64‰∫åËøõÂà∂Êñá‰ª∂ËøõË°åÊµãËØï
        BINARY_URL="https://github.com/${{ github.repository }}/releases/download/$RELEASE_TAG/hpn-$RELEASE_TAG-linux-amd64.tar.gz"
        
        echo "Downloading: $BINARY_URL"
        curl -L -o hpn-release.tar.gz "$BINARY_URL" || {
          echo "‚ùå Failed to download release binary"
          exit 1
        }
        
        # Ëß£ÂéãÂπ∂ÊµãËØï
        tar -xzf hpn-release.tar.gz
        chmod +x hpn-linux-amd64
        
        # ÊÄßËÉΩÊµãËØï
        echo "üöÄ Running performance tests..."
        
        # ÊµãËØïÂêØÂä®Êó∂Èó¥
        START_TIME=$(date +%s%N)
        ./hpn-linux-amd64 --version > /dev/null
        END_TIME=$(date +%s%N)
        STARTUP_TIME=$(( (END_TIME - START_TIME) / 1000000 )) # ËΩ¨Êç¢‰∏∫ÊØ´Áßí
        
        echo "Startup time: ${STARTUP_TIME}ms"
        
        # ÊµãËØïÂÜÖÂ≠ò‰ΩøÁî®
        MEMORY_USAGE=$(timeout 10s /usr/bin/time -v ./hpn-linux-amd64 --help 2>&1 | grep "Maximum resident set size" | awk '{print $6}' || echo "0")
        echo "Memory usage: ${MEMORY_USAGE}KB"
        
        # ÊµãËØï‰∫åËøõÂà∂Êñá‰ª∂Â§ßÂ∞è
        BINARY_SIZE=$(stat -c%s hpn-linux-amd64)
        BINARY_SIZE_MB=$(( BINARY_SIZE / 1024 / 1024 ))
        echo "Binary size: ${BINARY_SIZE_MB}MB"
        
        # ÊÄßËÉΩËØÑ‰º∞
        PERFORMANCE_SCORE=100
        
        if [ $STARTUP_TIME -gt 1000 ]; then
          echo "‚ö†Ô∏è  Slow startup time: ${STARTUP_TIME}ms"
          PERFORMANCE_SCORE=$((PERFORMANCE_SCORE - 20))
        fi
        
        if [ $MEMORY_USAGE -gt 50000 ]; then
          echo "‚ö†Ô∏è  High memory usage: ${MEMORY_USAGE}KB"
          PERFORMANCE_SCORE=$((PERFORMANCE_SCORE - 15))
        fi
        
        if [ $BINARY_SIZE_MB -gt 50 ]; then
          echo "‚ö†Ô∏è  Large binary size: ${BINARY_SIZE_MB}MB"
          PERFORMANCE_SCORE=$((PERFORMANCE_SCORE - 10))
        fi
        
        echo "Performance score: $PERFORMANCE_SCORE/100"
        
        # Â≠òÂÇ®ÊÄßËÉΩÊåáÊ†á
        mkdir -p .monitoring/performance
        TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        
        cat > ".monitoring/performance/$RELEASE_TAG-$TIMESTAMP.json" << EOF
        {
          "timestamp": "$TIMESTAMP",
          "release_tag": "$RELEASE_TAG",
          "startup_time_ms": $STARTUP_TIME,
          "memory_usage_kb": $MEMORY_USAGE,
          "binary_size_bytes": $BINARY_SIZE,
          "performance_score": $PERFORMANCE_SCORE
        }
        EOF

    - name: Upload performance metrics
      uses: actions/upload-artifact@v3
      with:
        name: performance-metrics
        path: .monitoring/performance/
        retention-days: ${{ env.MONITORING_RETENTION_DAYS }}

  # ÁõëÊéßÈîôËØØÂíåÈóÆÈ¢ò
  monitor-errors:
    name: Monitor Errors
    runs-on: ubuntu-latest
    needs: detect-release
    if: needs.detect-release.outputs.should-monitor == 'true'
    outputs:
      error-count: ${{ steps.errors.outputs.count }}
      critical-issues: ${{ steps.errors.outputs.critical }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Check for release-related issues
      id: errors
      run: |
        RELEASE_TAG="${{ needs.detect-release.outputs.release-tag }}"
        RELEASE_DATE="${{ needs.detect-release.outputs.release-date }}"
        
        echo "üîç Checking for issues related to $RELEASE_TAG..."
        
        # ÊêúÁ¥¢‰∏éÂèëÂ∏ÉÁõ∏ÂÖ≥ÁöÑÈóÆÈ¢ò
        ISSUES_JSON=$(gh issue list --state open --json number,title,labels,createdAt --limit 50)
        
        # ËøáÊª§ÂèëÂ∏ÉÂêéÂàõÂª∫ÁöÑÈóÆÈ¢ò
        RELEASE_TIMESTAMP=$(date -d "$RELEASE_DATE" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$RELEASE_DATE" +%s)
        
        RECENT_ISSUES=0
        CRITICAL_ISSUES=0
        BUG_ISSUES=0
        
        echo "$ISSUES_JSON" | jq -c '.[]' | while read -r issue; do
          CREATED_AT=$(echo "$issue" | jq -r '.createdAt')
          ISSUE_TIMESTAMP=$(date -d "$CREATED_AT" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$CREATED_AT" +%s)
          
          if [ $ISSUE_TIMESTAMP -gt $RELEASE_TIMESTAMP ]; then
            RECENT_ISSUES=$((RECENT_ISSUES + 1))
            
            TITLE=$(echo "$issue" | jq -r '.title')
            LABELS=$(echo "$issue" | jq -r '.labels[].name' | tr '\n' ' ')
            
            echo "Recent issue: $TITLE (Labels: $LABELS)"
            
            # Ê£ÄÊü•ÊòØÂê¶‰∏∫ÂÖ≥ÈîÆÈóÆÈ¢ò
            if echo "$LABELS" | grep -q -E "(critical|urgent|security|crash)"; then
              CRITICAL_ISSUES=$((CRITICAL_ISSUES + 1))
            fi
            
            # Ê£ÄÊü•ÊòØÂê¶‰∏∫bug
            if echo "$LABELS" | grep -q "bug"; then
              BUG_ISSUES=$((BUG_ISSUES + 1))
            fi
          fi
        done
        
        echo "count=$RECENT_ISSUES" >> $GITHUB_OUTPUT
        echo "critical=$CRITICAL_ISSUES" >> $GITHUB_OUTPUT
        
        echo "üìä Issue summary:"
        echo "  Recent issues: $RECENT_ISSUES"
        echo "  Critical issues: $CRITICAL_ISSUES"
        echo "  Bug reports: $BUG_ISSUES"
        
        # ËØÑ‰º∞ÈóÆÈ¢ò‰∏•ÈáçÁ®ãÂ∫¶
        if [ $CRITICAL_ISSUES -gt 0 ]; then
          echo "üö® Critical issues detected - immediate attention required!"
        elif [ $BUG_ISSUES -gt 3 ]; then
          echo "‚ö†Ô∏è  Multiple bug reports - investigation recommended"
        elif [ $RECENT_ISSUES -gt 10 ]; then
          echo "üìà High issue volume - monitor closely"
        else
          echo "‚úÖ Issue levels are normal"
        fi
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Êî∂ÈõÜÁî®Êà∑ÂèçÈ¶à
  collect-feedback:
    name: Collect User Feedback
    runs-on: ubuntu-latest
    needs: detect-release
    if: needs.detect-release.outputs.should-monitor == 'true'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Analyze discussions and feedback
      run: |
        RELEASE_TAG="${{ needs.detect-release.outputs.release-tag }}"
        
        echo "üí¨ Analyzing user feedback for $RELEASE_TAG..."
        
        # ÊêúÁ¥¢ËÆ®ËÆ∫‰∏≠ÁöÑÂèçÈ¶à
        DISCUSSIONS=$(gh api graphql -f query='
          query($owner: String!, $repo: String!) {
            repository(owner: $owner, name: $repo) {
              discussions(first: 20, orderBy: {field: CREATED_AT, direction: DESC}) {
                nodes {
                  title
                  body
                  createdAt
                  category {
                    name
                  }
                  reactions {
                    totalCount
                  }
                }
              }
            }
          }' -f owner="${{ github.repository_owner }}" -f repo="${{ github.event.repository.name }}" 2>/dev/null || echo '{"data":{"repository":{"discussions":{"nodes":[]}}}}')
        
        # ÂàÜÊûêÂèçÈ¶àÊÉÖÁª™
        POSITIVE_FEEDBACK=0
        NEGATIVE_FEEDBACK=0
        FEATURE_REQUESTS=0
        
        echo "$DISCUSSIONS" | jq -r '.data.repository.discussions.nodes[] | select(.title | test("'$RELEASE_TAG'|release|feedback"; "i")) | .title + ": " + .body' | while read -r feedback; do
          if echo "$feedback" | grep -q -E "(great|awesome|excellent|love|perfect|amazing)"; then
            POSITIVE_FEEDBACK=$((POSITIVE_FEEDBACK + 1))
          elif echo "$feedback" | grep -q -E "(issue|problem|bug|broken|fail|error)"; then
            NEGATIVE_FEEDBACK=$((NEGATIVE_FEEDBACK + 1))
          elif echo "$feedback" | grep -q -E "(request|feature|enhancement|improve|add)"; then
            FEATURE_REQUESTS=$((FEATURE_REQUESTS + 1))
          fi
        done
        
        echo "üìä Feedback analysis:"
        echo "  Positive feedback: $POSITIVE_FEEDBACK"
        echo "  Negative feedback: $NEGATIVE_FEEDBACK"
        echo "  Feature requests: $FEATURE_REQUESTS"
        
        # Â≠òÂÇ®ÂèçÈ¶àÂàÜÊûê
        mkdir -p .monitoring/feedback
        TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        
        cat > ".monitoring/feedback/$RELEASE_TAG-$TIMESTAMP.json" << EOF
        {
          "timestamp": "$TIMESTAMP",
          "release_tag": "$RELEASE_TAG",
          "positive_feedback": $POSITIVE_FEEDBACK,
          "negative_feedback": $NEGATIVE_FEEDBACK,
          "feature_requests": $FEATURE_REQUESTS
        }
        EOF
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Upload feedback metrics
      uses: actions/upload-artifact@v3
      with:
        name: feedback-metrics
        path: .monitoring/feedback/
        retention-days: ${{ env.MONITORING_RETENTION_DAYS }}

  # ÁîüÊàêË¥®ÈáèÊä•Âëä
  generate-quality-report:
    name: Generate Quality Report
    runs-on: ubuntu-latest
    needs: [detect-release, monitor-downloads, monitor-performance, monitor-errors, collect-feedback]
    if: always() && needs.detect-release.outputs.should-monitor == 'true'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download all metrics
      uses: actions/download-artifact@v3
      with:
        path: metrics/

    - name: Generate comprehensive report
      run: |
        RELEASE_TAG="${{ needs.detect-release.outputs.release-tag }}"
        RELEASE_DATE="${{ needs.detect-release.outputs.release-date }}"
        
        echo "üìä Generating quality report for $RELEASE_TAG..."
        
        # ÂàõÂª∫Êä•ÂëäÁõÆÂΩï
        mkdir -p reports
        REPORT_FILE="reports/quality-report-$RELEASE_TAG-$(date +%Y%m%d-%H%M%S).md"
        
        # ÁîüÊàêÊä•Âëä
        cat > "$REPORT_FILE" << EOF
        # Quality Report: $RELEASE_TAG
        
        **Generated:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
        **Release Date:** $RELEASE_DATE
        
        ## Executive Summary
        
        This report provides a comprehensive analysis of the $RELEASE_TAG release quality and user adoption.
        
        ## Download Statistics
        
        EOF
        
        # Ê∑ªÂä†‰∏ãËΩΩÁªüËÆ°
        if [ -f "metrics/download-metrics" ]; then
          DOWNLOAD_STATS="${{ needs.monitor-downloads.outputs.download-stats }}"
          TOTAL_DOWNLOADS=$(echo "$DOWNLOAD_STATS" | jq -r '.total_downloads // 0')
          DOWNLOADS_PER_HOUR=$(echo "$DOWNLOAD_STATS" | jq -r '.downloads_per_hour // 0')
          
          cat >> "$REPORT_FILE" << EOF
        - **Total Downloads:** $TOTAL_DOWNLOADS
        - **Downloads per Hour:** $DOWNLOADS_PER_HOUR
        - **Adoption Rate:** $([ $DOWNLOADS_PER_HOUR -ge 5 ] && echo "High" || echo "Moderate")
        
        EOF
        fi
        
        # Ê∑ªÂä†ÊÄßËÉΩÊåáÊ†á
        cat >> "$REPORT_FILE" << EOF
        ## Performance Metrics
        
        EOF
        
        if [ -f "metrics/performance-metrics" ]; then
          echo "Performance data available - processing..." >> "$REPORT_FILE"
        else
          echo "Performance data not available for this report." >> "$REPORT_FILE"
        fi
        
        # Ê∑ªÂä†ÈîôËØØÂàÜÊûê
        cat >> "$REPORT_FILE" << EOF
        
        ## Error Analysis
        
        EOF
        
        ERROR_COUNT="${{ needs.monitor-errors.outputs.error-count }}"
        CRITICAL_ISSUES="${{ needs.monitor-errors.outputs.critical-issues }}"
        
        cat >> "$REPORT_FILE" << EOF
        - **Recent Issues:** $ERROR_COUNT
        - **Critical Issues:** $CRITICAL_ISSUES
        - **Quality Status:** $([ $CRITICAL_ISSUES -eq 0 ] && echo "‚úÖ Stable" || echo "‚ö†Ô∏è Needs Attention")
        
        ## User Feedback
        
        EOF
        
        if [ -f "metrics/feedback-metrics" ]; then
          echo "User feedback analysis available." >> "$REPORT_FILE"
        else
          echo "No user feedback data available for this period." >> "$REPORT_FILE"
        fi
        
        # Ê∑ªÂä†Âª∫ËÆÆ
        cat >> "$REPORT_FILE" << EOF
        
        ## Recommendations
        
        EOF
        
        if [ $CRITICAL_ISSUES -gt 0 ]; then
          echo "- üö® **Immediate Action Required:** Address critical issues" >> "$REPORT_FILE"
        fi
        
        if [ $DOWNLOADS_PER_HOUR -lt 2 ]; then
          echo "- üì¢ **Marketing:** Consider promoting the release to increase adoption" >> "$REPORT_FILE"
        fi
        
        if [ $ERROR_COUNT -gt 5 ]; then
          echo "- üîç **Investigation:** High issue volume requires investigation" >> "$REPORT_FILE"
        fi
        
        echo "- üìä **Monitoring:** Continue monitoring for 48-72 hours post-release" >> "$REPORT_FILE"
        
        cat >> "$REPORT_FILE" << EOF
        
        ## Next Review
        
        Next quality review scheduled for: $(date -d "+24 hours" -u +"%Y-%m-%d %H:%M:%S UTC")
        
        ---
        
        *This report was automatically generated by the Release Monitoring system.*
        EOF
        
        echo "‚úÖ Quality report generated: $REPORT_FILE"

    - name: Upload quality report
      uses: actions/upload-artifact@v3
      with:
        name: quality-report
        path: reports/
        retention-days: 90

    - name: Create monitoring issue if needed
      if: needs.monitor-errors.outputs.critical-issues > 0
      uses: actions/github-script@v6
      with:
        script: |
          const releaseTag = '${{ needs.detect-release.outputs.release-tag }}';
          const criticalIssues = '${{ needs.monitor-errors.outputs.critical-issues }}';
          
          const issue = await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `üö® Critical Issues Detected in ${releaseTag}`,
            body: `## Release Monitoring Alert
          
          **Release:** ${releaseTag}
          **Critical Issues:** ${criticalIssues}
          **Detection Time:** ${new Date().toISOString()}
          
          ### Summary
          
          The automated monitoring system has detected ${criticalIssues} critical issue(s) related to the ${releaseTag} release.
          
          ### Required Actions
          
          - [ ] Review critical issues immediately
          - [ ] Assess impact on users
          - [ ] Determine if hotfix is required
          - [ ] Update monitoring status
          
          ### Monitoring Data
          
          Full monitoring data and quality report are available in the [workflow run](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}).
          
          ---
          
          *This issue was automatically created by the Release Monitoring system.*`,
            labels: ['monitoring', 'critical', 'release-issue']
          });
          
          console.log(`Created monitoring issue: ${issue.data.html_url}`);

  # ÁõëÊéßÊÄªÁªì
  monitoring-summary:
    name: Monitoring Summary
    runs-on: ubuntu-latest
    needs: [detect-release, monitor-downloads, monitor-performance, monitor-errors, collect-feedback, generate-quality-report]
    if: always() && needs.detect-release.outputs.should-monitor == 'true'
    steps:
    - name: Generate monitoring summary
      run: |
        RELEASE_TAG="${{ needs.detect-release.outputs.release-tag }}"
        
        echo "## üìä Release Monitoring Summary: $RELEASE_TAG" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Ê£ÄÊü•ÂêÑÈ°πÁõëÊéßÁä∂ÊÄÅ
        DOWNLOADS_STATUS="${{ needs.monitor-downloads.result }}"
        PERFORMANCE_STATUS="${{ needs.monitor-performance.result }}"
        ERRORS_STATUS="${{ needs.monitor-errors.result }}"
        FEEDBACK_STATUS="${{ needs.collect-feedback.result }}"
        REPORT_STATUS="${{ needs.generate-quality-report.result }}"
        
        echo "### Monitoring Results" >> $GITHUB_STEP_SUMMARY
        echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| Download Monitoring | $DOWNLOADS_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "| Performance Monitoring | $PERFORMANCE_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "| Error Monitoring | $ERRORS_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "| Feedback Collection | $FEEDBACK_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "| Quality Report | $REPORT_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Ê∑ªÂä†ÂÖ≥ÈîÆÊåáÊ†á
        ERROR_COUNT="${{ needs.monitor-errors.outputs.error-count }}"
        CRITICAL_ISSUES="${{ needs.monitor-errors.outputs.critical-issues }}"
        
        echo "### Key Metrics" >> $GITHUB_STEP_SUMMARY
        echo "- **Release Tag:** $RELEASE_TAG" >> $GITHUB_STEP_SUMMARY
        echo "- **Recent Issues:** $ERROR_COUNT" >> $GITHUB_STEP_SUMMARY
        echo "- **Critical Issues:** $CRITICAL_ISSUES" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Êï¥‰ΩìÂÅ•Â∫∑Áä∂ÊÄÅ
        if [ "$CRITICAL_ISSUES" -gt 0 ]; then
          echo "### üö® **Status: Critical Issues Detected**" >> $GITHUB_STEP_SUMMARY
          echo "Immediate attention required for critical issues." >> $GITHUB_STEP_SUMMARY
        elif [ "$ERROR_COUNT" -gt 5 ]; then
          echo "### ‚ö†Ô∏è  **Status: Elevated Issue Volume**" >> $GITHUB_STEP_SUMMARY
          echo "Higher than normal issue volume detected." >> $GITHUB_STEP_SUMMARY
        else
          echo "### ‚úÖ **Status: Healthy**" >> $GITHUB_STEP_SUMMARY
          echo "Release monitoring shows normal metrics." >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "1. Review detailed quality report in artifacts" >> $GITHUB_STEP_SUMMARY
        echo "2. Monitor trends over next 24-48 hours" >> $GITHUB_STEP_SUMMARY
        echo "3. Address any critical issues immediately" >> $GITHUB_STEP_SUMMARY